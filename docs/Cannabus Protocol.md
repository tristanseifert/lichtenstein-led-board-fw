## Overview
All devices have an unique 16-bit ID, which is either provided by some hardware (such as a hardware serial number chip) or derived by software from some other unique per-device values.

Two device IDs are reserved:

- `0x0000`: Primary bus controller
- `0xFFFF`: Broadcast address

Each device can expose up to 2048 registers.

### Endianness
All multi-byte values are transmitted in network byte order, e.g. most significant byte first.

## CAN IDs
CAN message identifiers are generated by concatenating a single bit priority field, an acknowledge flag, the 16-bit device address, and the 11-bit register number.

Note that lower priority values indicate higher priorities, due to the way CAN bus arbitration works.

## Bus Operations
### Bus Reset
To reset all devices on the bus, the controller will send a remote transmission request frame with an identifier of all 1's. Remote devices should acknowledge the frame, then reset themselves upon receipt.

### Discovery
To scan for devices, the bus controller will send a remote transmission request frame to device `0xFFFF`, register address `0x000`, with the `RTR` bit set. The priority field is set to `0`.

All devices will then respond with their own device address, and the contents of register `0x000`. Devices may insert a randomly generated delay (up to 1 second) between receipt of this message and sending a response. Bus arbitration will take care of ensuring that all devices will be seen by the bus controller.

### Reading Registers
To read a register, the bus controller will send a remote transmission request frame to the device and register, with the `RTR` bit set.

The device will respond with the register data.

Note that the priority field is copied from the request to the response, and the ACK field will be set.

### Writing Registers
To write a register, the bus controller will send a regular data frame to the device and register, with the `RTR` bit cleared.

The device will interpret this as a request to write this register, and will update the register contents, then respond with an ACK frame.

## Reserved Registers
There are several registers that are reserved for the Cannabus protocol:

### `0x0000` – Device ID Register
This is an 8 byte register that is structured as follows:

- Bytes 1-2: (RW) Device ID (used on the bus; can be written to to re-program the device)
- Byte 3: (RO) Supported Cannabus version (currently `0x08`)
- Byte 4: (RO) Device Type
- Byte 5: (RO) Firmware upgrade support bitfield
	- Bit 7: Remote firmware upgrade supported
	- Bit 6: Compressed firmware upgrade supported
	- Bit 5: Signed firmware upgrade supported
	- Bits 4-0: Power-of-two firmware size
- Bytes 6-7: (RO) Firmware version (provided by app)
- Byte 8: (RO) Reserved for future expansion; if updating the register, keep them as-is.

### `0x0001` – Device Control Register
This is a single byte register, set up as a bitfield. When read, the bits have the following meaning:

- Bits 7-0: Reserved, should be 0.

When written, the bits have the following meaning:

- Bit 7: When written as a 1, the device resets.
- Bits 6-0: Reserved, write as 0.

### `0x0002` – Firmware Upgrade Control Register
Writes to this register can be used to start/cancel the firmware upgrade. The data written should be as follows:

- Bytes 1-3: Magic value `0x042069`
- Byte 4: Reserved, write as 0.
- Bytes 5-6: 16-bit CRC of the firmware to be sent.
- Byte 7: Write as 0x01 to initiate a firmware upgrade, or 0x02 to cancel a firmware ugprade already in progress.
- Byte 8: Reserved, set to 0.

### `0x0003` – Firmware Upgrade Data Register
If firmware upgrades are supported, this register allows firmware data to be loaded into the controller 8 bytes at a time.

When a message with less than 8 bytes of data is received, the controller will assume that this is the end of the transmitted firmware, and reset to boot this new firmware.

When read, the register is a four byte status register:

- Byte 1: Status bitfield
	- Bit 7: Upgrade in progress
	- Bit 6: Upgrade complete
	- Bit 0: Ready for more data

When written, all bytes from the message are appended to the firmware buffer.